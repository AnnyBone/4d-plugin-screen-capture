/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : Screen Capture
 #	author : miyako
 #	2013/12/14
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin.h"

void PluginMain(int32_t selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (int32_t pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Windows

		case 1 :
			CAPTURE_Window(pResult, pParams);
			break;

	}
}

// ------------------------------------ Windows -----------------------------------

void CAPTURE_Window(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_PICTURE Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);
	
#if VERSIONMAC
	
	if(!Param1.getIntValue()){
		//capture desktop
		CGImageRef image = CGWindowListCreateImage(CGRectInfinite, 
												   kCGWindowListOptionOnScreenOnly, 
												   kCGNullWindowID, 
												   kCGWindowImageBoundsIgnoreFraming);
		
		if(image)
		{
			Param2.setImage(image);
			CGImageRelease(image);
			returnValue.setIntValue(1);
		}
		
	}else{
		
		PA_WindowRef windowRef = reinterpret_cast<PA_WindowRef>(Param1.getIntValue());
		OpaqueWindowPtr* windowPtr = reinterpret_cast<OpaqueWindowPtr*>(windowRef);
		//capture window
		CGImageRef image = CGWindowListCreateImage(CGRectNull, 
												   kCGWindowListOptionIncludingWindow, 
												   HIWindowGetCGWindowID(windowPtr), 
												   kCGWindowImageBoundsIgnoreFraming);
		if(image)
		{
			Param2.setImage(image);
			CGImageRelease(image);
			returnValue.setIntValue(1);
		}
	}

#else
	
	HWND	windowRef = NULL;
	RECT    rect;
	
	int w, h;	
 		
	if(!Param1.getIntValue()){
		//capture desktop
		windowRef = GetDesktopWindow();
	}else{
		//capture window
		PA_WindowRef windowId = reinterpret_cast<PA_WindowRef>(Param1.getIntValue());
		windowRef = reinterpret_cast<HWND>(PA_GetHWND(windowId));
	}

	GetWindowRect(windowRef, &rect);

	w = rect.right - rect.left;     
	h = rect.bottom - rect.top;

	_captureWindow(windowRef, w, h, Param2);

#endif	
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

#if VERSIONWIN
int _captureWindow(HWND	windowRef, int w, int h, C_PICTURE &picture)
{
	int success				= 0;

	if(windowRef)
	{	
		HDC		hdcWindow, hdcMemDC; 
		HBITMAP	hbmWindow;

		hdcWindow	= GetWindowDC(windowRef);
		
		if(hdcWindow)
		{			
			hdcMemDC	= CreateCompatibleDC(hdcWindow); 
			
			if(hdcMemDC)
			{
				hbmWindow = CreateCompatibleBitmap(hdcWindow, w, h);  
				
				if(hbmWindow)
				{
					HGDIOBJ oldObject = SelectObject(hdcMemDC, hbmWindow);
					PrintWindow(windowRef, hdcMemDC, 0);
					BitBlt(hdcMemDC, 0, 0, w, h, hdcWindow, 0, 0, SRCCOPY);					
					
					_captureWindow(hbmWindow, hdcWindow, w, h, picture);
					
					SelectObject(hdcMemDC, oldObject); 

					DeleteObject(hbmWindow);
				}//CreateCompatibleBitmap
				DeleteDC(hdcMemDC); 
			}//CreateCompatibleDC
			DeleteDC(hdcWindow);     
		}//CreateDC

	}

	return success;	
}

int _captureWindow(HBITMAP hbmWindow, HDC hdcWindow, int w, int h, C_PICTURE &picture)
{
	int success				= 0;
	
	if(hbmWindow)
	{
		
		BITMAPINFO			bmpInfo;
		ZeroMemory(&bmpInfo,sizeof(BITMAPINFO));
		bmpInfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
		GetDIBits(hdcWindow, hbmWindow, 0, 0, NULL, &bmpInfo, DIB_RGB_COLORS);  
		
		BITMAPINFOHEADER	bi;
		bi.biSize = sizeof(BITMAPINFOHEADER);    
		bi.biWidth = w;    
		bi.biHeight = h;  
		bi.biPlanes = 1;    
		bi.biBitCount = 32;    
		bi.biCompression = BI_RGB;    
		bi.biSizeImage = 0;  
		bi.biXPelsPerMeter = 0;    
		bi.biYPelsPerMeter = 0;    
		bi.biClrUsed = 0;    
		bi.biClrImportant = 0;

		bi.biSizeImage = bmpInfo.bmiHeader.biSizeImage;

		HANDLE hDIB = GlobalAlloc(GHND,bi.biSizeImage+sizeof(BITMAPINFOHEADER)); 

		if(hDIB)
		{
			LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); 
			
			if(lpbi)
			{

				*lpbi = bi;

				std::vector<char> bits(bi.biSizeImage);
				GetDIBits(hdcWindow, hbmWindow, 0, bi.biHeight, &bits[0], (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

				size_t bfSize			= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + bi.biSizeImage;
				
				BITMAPFILEHEADER		bmfHeader;  
				
				bmfHeader.bfType		= 0x4D42; //BM  
				bmfHeader.bfSize		= bfSize;
				bmfHeader.bfReserved1	= 0;     
				bmfHeader.bfReserved2	= 0; 
				bmfHeader.bfOffBits		= (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER); 
				
				std::vector<char> buf(bfSize);
				
				//copy the file header
				memcpy(&buf[0], &bmfHeader, sizeof(BITMAPFILEHEADER));
				//copy the info header and bits
				memcpy(&buf[0] + sizeof(BITMAPFILEHEADER), lpbi, sizeof(BITMAPINFOHEADER));
				//copy the bits
				memcpy(&buf[0] + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER), &bits[0], lpbi->biSizeImage);
				
				picture.setPicture(PA_CreatePicture(&buf[0], bfSize));
				success = 1;	

				GlobalUnlock(hDIB);  	
			}//GlobalLock
			GlobalFree(hDIB);					
		}//GlobalAlloc
		
	}
	return success;							   
}
#endif