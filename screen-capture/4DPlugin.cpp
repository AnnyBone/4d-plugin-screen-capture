/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : screen-capture
 #	author : miyako
 #	2017/03/14
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Capture

		case 1 :
			Capture_screen(pResult, pParams);
			break;

		case 2 :
			Capture_window(pResult, pParams);
			break;

	}
}

// ------------------------------------ Capture -----------------------------------

#if VERSIONMAC
NSWindow *PA_GetWindowRef64(int winId)
{
	//EX_GET_HWND has been fixed in 15R3 to return a NSWindow* on mac 64bit.
	//http://forums.4d.fr/Post/EN/15872830/1/17032044
	
	PA_ulong32 version = (PA_Get4DVersion() & 0x0000FFFF);
	//	int minor = version & 0x000F;
	int r = (version & 0x00F0) >> 4;
	int major = (version & 0xFF00) >> 8;
	if (((major >=0x15) && (r >= 3)) || (major >=0x16))
	{
		return (NSWindow *)PA_GetWindowPtr(reinterpret_cast<NSWindow *>(winId));
	}
	return 0;
}
CGWindowID getWindowId(C_LONGINT &Param1)
{
#if CGFLOAT_IS_DOUBLE
	NSWindow *window = PA_GetWindowRef64(Param1.getIntValue());
	return window ? [window windowNumber] : kCGNullWindowID;
#else
	return HIWindowGetCGWindowID(reinterpret_cast<WindowRef>(PA_GetWindowPtr(reinterpret_cast<PA_WindowRef>(Param1.getIntValue()))));
#endif
}

void getWindowImage(CGWindowID windowId, CGWindowListOption option, C_PICTURE &returnValue)
{
	CGImageRef image = CGWindowListCreateImage(CGRectNull,
																						 option,
																						 windowId,
																						 kCGWindowImageBoundsIgnoreFraming);
	if(image)
	{
		NSImage * img = [[NSImage alloc]initWithCGImage:image size:NSZeroSize];
		returnValue.setImage(img);
		[img release];
		CGImageRelease(image);
	}
}
#else
void captureWindow(HBITMAP hbmWindow, HDC hdcWindow, int w, int h, C_PICTURE &picture)
{
	if(hbmWindow)
	{
		BITMAPINFO bmpInfo;
		ZeroMemory(&bmpInfo,sizeof(BITMAPINFO));
		bmpInfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
		GetDIBits(hdcWindow, hbmWindow, 0, 0, NULL, &bmpInfo, DIB_RGB_COLORS);
		
		BITMAPINFOHEADER bi;
		bi.biSize = sizeof(BITMAPINFOHEADER);
		bi.biWidth = w;
		bi.biHeight = h;
		bi.biPlanes = 1;
		bi.biBitCount = 32;
		bi.biCompression = BI_RGB;
		bi.biSizeImage = 0;
		bi.biXPelsPerMeter = 0;
		bi.biYPelsPerMeter = 0;
		bi.biClrUsed = 0;
		bi.biClrImportant = 0;
		
		bi.biSizeImage = bmpInfo.bmiHeader.biSizeImage;
		
		HANDLE hDIB = GlobalAlloc(GHND,bi.biSizeImage+sizeof(BITMAPINFOHEADER));
		
		if(hDIB)
		{
			LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
			
			if(lpbi)
			{
				
				*lpbi = bi;
				
				std::vector<char> bits(bi.biSizeImage);
				GetDIBits(hdcWindow, hbmWindow, 0, bi.biHeight, &bits[0], (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);
				
				size_t bfSize			= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + bi.biSizeImage;
				
				BITMAPFILEHEADER		bmfHeader;
				
				bmfHeader.bfType		= 0x4D42; //BM
				bmfHeader.bfSize		= bfSize;
				bmfHeader.bfReserved1	= 0;
				bmfHeader.bfReserved2	= 0;
				bmfHeader.bfOffBits		= (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);
				
				std::vector<char> buf(bfSize);
				
				//copy the file header
				memcpy(&buf[0], &bmfHeader, sizeof(BITMAPFILEHEADER));
				//copy the info header and bits
				memcpy(&buf[0] + sizeof(BITMAPFILEHEADER), lpbi, sizeof(BITMAPINFOHEADER));
				//copy the bits
				memcpy(&buf[0] + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER), &bits[0], lpbi->biSizeImage);
				
				picture.setPicture(PA_CreatePicture(&buf[0], bfSize));
				
				GlobalUnlock(hDIB);
			}//GlobalLock
			GlobalFree(hDIB);
		}//GlobalAlloc
		
	}//hbmWindow
	
}
void getWindowImage(HWND windowRef, C_PICTURE &returnValue)
{
	if(windowRef)
	{
		RECT rect;
		GetWindowRect(windowRef, &rect);
		int w = rect.right - rect.left;
		int h = rect.bottom - rect.top;
		
		HDC		hdcWindow, hdcMemDC;
		HBITMAP	hbmWindow;
		hdcWindow	= GetWindowDC(windowRef);
		if(hdcWindow)
		{
			hdcMemDC	= CreateCompatibleDC(hdcWindow);
			if(hdcMemDC)
			{
				hbmWindow = CreateCompatibleBitmap(hdcWindow, w, h);
				
				if(hbmWindow)
				{
					HGDIOBJ oldObject = SelectObject(hdcMemDC, hbmWindow);
					PrintWindow(windowRef, hdcMemDC, 0);
					BitBlt(hdcMemDC, 0, 0, w, h, hdcWindow, 0, 0, SRCCOPY);
					
					captureWindow(hbmWindow, hdcWindow, w, h, returnValue);
					
					SelectObject(hdcMemDC, oldObject);
					DeleteObject(hbmWindow);
				}//CreateCompatibleBitmap
				DeleteDC(hdcMemDC);
			}//CreateCompatibleDC
			DeleteDC(hdcWindow);
		}//CreateDC
		
	}//windowRef
	
}
#endif

void Capture_screen(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_PICTURE returnValue;
	
#if VERSIONMAC
	getWindowImage(kCGNullWindowID, kCGWindowListOptionOnScreenOnly, returnValue);
#else
	getWindowImage(GetDesktopWindow(), returnValue);
#endif
	
	returnValue.setReturn(pResult);
}

void Capture_window(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_PICTURE returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
#if VERSIONMAC
	CGWindowID winId = getWindowId(Param1);
	if(winId != kCGNullWindowID)
		getWindowImage(winId, kCGWindowListOptionIncludingWindow, returnValue);
#else
	HWND windowRef = reinterpret_cast<HWND>(PA_GetHWND(reinterpret_cast<PA_WindowRef>(Param1.getIntValue())));
	getWindowImage(windowRef, returnValue);
#endif
	
	returnValue.setReturn(pResult);
}

